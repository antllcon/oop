Основы синтаксиса языка C++
Целочисленные типы данных
Каковы основные типы целых чисел в C++?
Как объявить переменную целого типа в C++?
Каковы диапазоны значений для различных типов целых чисел в C++?
Каковы основные операции, которые можно выполнять с целыми числами в C++?
Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
Как проверить, является ли целое число четным или нечетным в C++?
Как вычислить остаток от деления двух целых чисел в C++?
Чему равно частное и остаток при делении, когда один или оба аргумента — отрицательные?
Как проверить, является ли целое число положительным или отрицательным в C++?
Как использовать условные операторы и циклы для работы с целыми числами в C++?
Как проверить, что при умножении двух целых чисел не будет переполнения?
Типы данных вещественных чисел
Какие типы вещественных чисел существуют в C++?
Как объявить переменную вещественного типа в C++?
Каковы диапазоны значений для различных типов вещественных чисел в C++?
Какие операции можно выполнять с вещественными числами в C++?
Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
Какие математические функции доступны в C++ для работы с вещественными числами?
Как проверить, является ли вещественное число положительным или отрицательным в C++?
Как проверить, является ли вещественное число целым в C++?
Как округлить вещественное число до целого в C++?
Как сравнить два вещественных числа на равенство в C++?
Логический тип данных
Какой тип данных используется для хранения логических значений в C++?
Какие значения может принимать логический тип в C++?
Как объявить переменную логического типа в C++?
Какие операторы сравнения могут использоваться с логическим типом в C++?
Какие логические операторы доступны в C++?
Какой результат выражения true && false в C++?
Какой результат выражения true || false в C++?
Какой результат выражения !true в C++?
Какой результат выражения (5 > 3) && (7 < 10) в C++?
Какой результат выражения (4 == 4) || (6 != 6) в C++?
Символьные литералы
Какие символьные литералы поддерживаются в языке С++?
Что такое символьный литерал, и как он объявляется в С++?
Какие символьные значения можно задать с помощью символьных литералов в С++?
Какой символьный литерал используется для обозначения перевода строки в С++?
Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
Приведите не менее 3 примеров символьных литералов в С++?
Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?
Как внутри символьного литерала задать символ с заданным кодом?
Строковые литералы
Как объявляется строковый литерал в языке C++?
Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
Каким образом можно задать пустую строку в языке C++?
Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
Как строковые литералы представляются в памяти?
Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы
Чем отличаются эти строковые литералы: L"Hello" от "Hello"?
Переменные
Объявление переменных
Автоматическое определение типа переменной
Объявление константной переменной.
Области видимости переменных.
Доступ к переменной, объявленной в другое единице трансляции.
Синонимы типов
Что такое синоним типа в языке C++ и для чего он используется?
Каким образом объявляются синонимы типов в языке C++?
Объявите синоним типов с помощью using.
Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
Как объявить синоним типа для пользовательского типа данных в языке C++?
Какие преимущества имеет использование синонимов типов в языке C++?
Каким образом можно определить новый тип данных с использованием typedef в языке C++?=
Перечислимый тип данных
Что такое перечислимый тип данных в языке C++ и для чего он используется?
Как объявляется перечислимый тип данных в языке C++?
Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
Какие значения могут принимать элементы перечислимого типа данных в языке C++?
Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
Как объявляется scoped enum в языке C++?
Как можно обратиться к элементу scoped enum в языке C++?
Что такое underlying type у scoped enum в языке C++ и как он используется?
Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?
Приведение типа
Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
Приведите пример неявного приведение типа в языке C++?
Приведение типа в стиле языка C.
Какие операторы приведения типов есть в языке C++ и для чего они нужны?
Управление ходом выполнения программы
Выражения, инструкции, блоки
Оператор if. Конструкция else if.
if constexpr. Для чего используется? Какие ограничения?
Оператор цикла for. Цикл for со счётчиком. Синтаксис.
Range-based for. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based for?
Оператор цикла while.
Оператор цикла do-while.
Досрочный выход из цикла и пропуск итерации цикла.
Как, находясь во внутреннем цикле, выйти из внешнего?
Оператор множественного выбора switch.
Для чего применяется атрибут [[fallthrough]]?
Функции
Объявление функции.
Определение функции.
Аргументы по умолчанию.
Как выйти из функции?
Лямбда функции.
Захват параметров лямбда функции по значению и по ссылке. Чем отличаются?
Можно ли изменить значение переменной, захваченной в лямбде по значению?
Какой код компилятор сгенерирует на основе лямбда-функции с пустым списком захвата? А если список параметров будет непустым?
Структуры
Для чего нужны структуры?
Как объявить структуру?
Что такое член структуры и как им можно управлять?
Способы инициализации структур?
Как обратиться к полю структуры?
Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
Указатель на структуру, как обратиться к полю структуры по указателю?
Массивы структур.
Размещение полей структур в памяти.
Массивы
Как объявить массив в C++?
Что такое индекс массива?
Как получить доступ к элементу массива по индексу?
Как узнать размер массива?
Можно ли изменить размер массива после его создания?
Как заполнить массив значениями по умолчанию?
Как отсортировать элементы массива в порядке убывания?
Как связаны строковые литералы и массивы символов?
Что такое std::array и как он отличается от обычного массива?
Объявление многомерных массивов. Объявление многомерного массива с помощью std::array.
Ссылки
Что такое ссылка, как она объявляется?
Константные ссылки.
Передача параметров в функцию по значению, по ссылке, по константной ссылке.
Особенности работы ссылок на временные объекты. Чему равно время жизни временного объекта, на который ссылается ссылка?
Чему равно выражение sizeof(ref), где ref — ссылка?
Как хранятся ссылки внутри классов и структур?
Что на самом деле передаётся в функцию, принимающую аргумент по ссылке?
Пространства имён
Что такое пространство имён?
Как объявить пространство имён в C++?
Можно ли использовать несколько пространств имён в одном файле?
Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
Какие стандартные пространства имён существуют в C++?
Можно ли создавать свои собственные пространства имён?
Каким образом можно использовать элементы из других пространств имён?
Что такое алиасы (синонимы) пространства имён и как их объявлять?
Какой синтаксис используется при обращении к элементам вложенных пространств имён?
Безымянное пространство имён. Как его объявить, для чего отличается?
Модель памяти C++
Что такое объект с точки зрения модели памяти языка? Какими свойствами он обладает?
Что такое выравнивание? Для чего оно используется?
Чем размер объекта отличается от его выравнивания?
Выравнивание структур.
Как узнать размер объекта?
Как узнать выравнивание объекта?
Указатели
Что такое указатель? Для чего применяются указатели?
Как объявить указатель на переменную определенного типа?
Как получить адрес переменной в памяти и сохранить его в указатель?
Как получить значение переменной по ее адресу, на который указывает указатель?
Как изменить значение переменной по ее адресу, на который указывает указатель?
Как проверить, равны ли два указателя?
Как проверить, является ли указатель нулевым?
Какие операции можно выполнять с указателями?
Какие ошибки могут возникнуть при работе с указателями?
В чем отличие ссылки от указателя?
Что такое указатель void*? Для чего применяется? Какие с ним возможны операции?
Чем отличаются указатели T*, const T*, T* const и const T* const?
Что такое адресная арифметика?
К каким указателям применимы операции адресной арифметики?
Статическое, автоматическое и динамическое размещение объектов в памяти
Как разместить объект в статической области памяти? Когда удаляется объект в статической области памяти?
Как разместить объект в автоматической области памяти? Когда удаляется объект в автоматической области памяти?
Как разместить объект в динамической области памяти? Когда удаляется объект в динамической области памяти?
Операторы new и delete. Для чего применяются?
Какие ошибки могут возникнуть при работе с объектами в динамической области памяти?
Стандартная библиотека языка C++
std::string и std::string_view
Класс std::string.
Какого внутреннее устройство std::string в типичных реализациях?
Какие операции можно выполнять над std::string?
Что такое small string optimization?
Какова сложность операций вставки и замены символов строки?
Класс std::string_view, чем отличается от std::string?
В каких случаях использовать std::string_view, а в каких std::string?
Чем отличается substr в std::string и std::string_view?
Как найти все вхождения некоторой подстроки в строке?
Как быстро найти все вхождения некоторой подстроки в строке?
Как преобразовать std::string в числовой тип данных и обратно?
Как можно ускорить работу со строками в C++?
std::vector
Что такое std::vector? Чем отличается от простого массива и std::array?
Описать внутреннее устройство std::vector. Желательно показать на схеме.
Что произойдёт с полностью заполненным vector, если выполнить операцию push_back?
Типичные операции над std::vector. Какая сложность этих операций?
Приёмы оптимизации производительности при работе с std::vector.
Метод at и операция []. В каких случаях какую из этих операций следует использовать?
Как обойти все элементы std::vector в прямом и обратном направлении?
Чем размер вектора отличается от его вместимости?
Что такое инвалидация итераторов? Какие операции над std::vector приводят к инвалидации его итераторов?
Чем отличаются emplace-методы от push/insert?
Идиома erase/remove.
Как развернуть содержимое std::vector за O(1) памяти и O(N) времени?
Как вставить в вектор элементы из другого контейнера, например из deque (в конец, в начало, в середину). Какова сложность этих операций?
std::deque
Контейнер std::deque. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
Как устроен контейнер std::deque внутри? Какие структуры данных используют типичные реализации этого контейнера?
Какие операции над std::deque приводят к инвалидации итераторов?
Основные операции над std::deque и их сложность.
Чем отличаются emplace-методы от push/insert
Отличия std::deque от std::list. Когда лучше применять deque, а когда list?
Какие операции над std::deque приводят к инвалидации ссылок?
Как развернуть std::deque?
Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину)?
std::list и std::forward_list
Контейнер std::list и std::forward_list, чем отличаются? Когда использовать list, а когда forward_list?
Какие операции поддерживает std::list, а какие std::forward_list?
Какие операции над list и forward_list приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
Как развернуть std::forward_list? Какова сложность этой операции по памяти и по времени?
Как отсортировать std::list? Какова сложность этой операции?
Как перенести элементы из одного списка в другой? Какова сложность этих операций?
Как удалить элементы std::list, удовлетворяющие заданному критерию?
Как удалить из std::list подряд идущие дубликаты? [1, 3, 2, 2, -8, 5, 1, 1, 1, 2] -> [1, 3, 2, -8, 5, 1, 2]
Как перенести элементы из одного forward_list в другой. Какова сложность этих операций?
Как отсортировать всё содержимое forward_list?
Как отсортировать диапазон элементов std::list и std::forward_list?
Контейнеры map и multimap
Контейнер std::map. Для чего используется?
Операции над map. Какова сложность этих операций?
В каком порядке находятся элементы std::map? Можно ли изменить порядок элементов? Если да, то как?
Могут ли в качестве ключей map использоваться пользовательские типы данных? Что для этого нужно сделать?
Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
Чем отличается вставка элементов c помощью map[key] = value от вставки map.emplace(key, value)?
Чем отличается вставка элементов c помощью map[key] = value от вставки map.at(key) = value?
Напишите функцию optional<string> TryGetValue(const map<int, string>& m, int key)
Как можно ускорить вставку в map?
Как быстро перенести элемент из одного контейнера map в другой map того же типа?
Как получить все значения multimap с заданным ключом?
В каких случаях использовать map, а в каких unordered_map?
Чем отличается emplace от try_emplace?
В каком порядке возможен обход элементов контейнера map?
Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию? Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?
Контейнеры unordered_map и unordered_multimap
Контейнер unordered_map. Для чего используется?
Операции над unordered_map. Их сложность.
Что означает "амортизированная константа" применительно к сложности операций?
В каком порядке хранятся элементы внутри unordered_map? Можно ли изменить порядок этих элементов?
Как можно ускорить вставку в unordered_map?
Чем отличается вставка элементов c помощью umap[key] = value от вставки umap.emplace(key, value)?
Чем отличается вставка элементов c помощью umap[key] = value от вставки umap.at(key) = value?
Напишите функцию optional<string> TryGetValue(const unordered_map<int, string>& m, int key).
Что нужно сделать, чтобы в качестве ключей unordered_map использовать пользовательские типы данных?
Что такое хеш-функция? Как она используется в unordered_map?
Как быстро перенести элемент из одного unordered_map в другой того же типа
Что такое bucket-ы в unordered_map? Как они влияют на производительность?
Что такое rehashing? Когда он возникает? Как можно им управлять?
Контейнер unordered_multimap. Чем отличается от unordered_map?
Как получить все элементы unordered_map с одним и тем же ключом?
В каком порядке возможен обход элементов unordered_map?
Когда использовать map, а когда unordered_map?
Как удалить из unordered_map не более N элементов, удовлетворяющих заданному критерию?
Контейнеры set и multiset
Контейнер std::set. Для чего используется?
Операции над set. Какова сложность этих операций?
В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
Как быстро перенести один элемент из одного контейнера set в другой того же типа?
Когда использовать set, а когда unordered_set?
Как можно ускорить вставку в set?
Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
Чем отличается insert от emplace?
Как удалить из set все элементы, удовлетворяющие заданному критерию? Как удалить из set не более N элементов, удовлетворяющих заданному критерию?
Контейнеры unordered_set и unordered_multiset
Контейнер std::unordered_set. Для чего используется?
Операции над unordered_set. Какова сложность этих операций?
В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
Когда использовать set, а когда unordered_set?
Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию? Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
Что такое хеш-функция? Как она используется в unordered_set?
Что такое bucket-ы в unordered_set? Как они влияют на производительность?
Что такое rehashing? Когда он возникает? Как можно им управлять?
Стандартные алгоритмы
Сортировка элементов. Простая и стабильная сортировка. Алгоритмы частичной сортировки.
Подсчёт элементов, удовлетворяющих заданному критерию.
Поиск минимума и максимума.
Нахождение медианы и процентилей.
Поиск элементов. Последовательный. Двоичный поиск. Алгоритмы быстрого поиска всех вхождений подстроки в строке.
Копирование и преобразование элементов.
Алгоритмы над отсортированными множествами элементов: пересечение, объединение, разность множеств.
std::optional
Для чего нужен класс std::optional?
Как узнать, содержит ли объект std::optional значение?
Как получить доступ к значению?
Какие ошибки могут возникнуть при работе с классом std::optional?
Напишите функцию, которая складывает два значения типа optional<int> и возвращает пустое значение, если хотя бы одно из слагаемых пустое, либо сумму чисел, если оба аргумента непустые.
std::variant
Для чего нужен класс std::variant?
Как проверить, содержит ли std::variant значение нужного типа или нет?
Может ли std::variant не содержать значение?
Как с помощью std::visit обработать все допустимые значения внутри std::variant?
Для чего нужен std::monotype? Приведите пример.
Реализуйте операцию StringOrInt operator+(const StringOrInt& a, const StringOrInt& b), где тип StringOrInt — это std::variant<std::string, int>. Сложение должно происходить по правилам языка JavaScript:
10 + 20 => 30
10 + "20" => "1020"
"10" + 20 = "1020"
"10" + "20" = "1020"
Стандартные умные указатели
Для чего нужны умные указатели?
Умный указатель std::unique_ptr. Какую семантику владения реализует этот умный указатель?
Как ли вернуть unique_ptr из функции?
Как вызвать функцию, принимающую unique_ptr по значению?
Как создать в динамической памяти объект, и обернуть его в unique_ptr?
Как использовать unique_ptr и shared_ptr для управления ресурсами, отличными от объектов в динамической памяти? Например, файлом, открытым функцией fopen?
Умный указатель std::shared_ptr. Какую семантику владения объектом реализует этот умный указатель?
Какие фундаментальные проблемы управления объектом имеет shared_ptr?
Умный указатель std::weak_ptr. Для чего применяется?
Как создать в динамической памяти объект и обернуть его в shared_ptr?
Как преобразовать std::shared_ptr<Derived> к std::shared_ptr<Base> и обратно?
Как внутри метода объекта, которым владеет shared_ptr, получить shared_ptr, ссылающийся на этот же самый объект? Для чего это может понадобиться?
Как на основе shared_ptr, который владеет на объектом-агрегатом (например, структурой), получить shared_ptr на составную часть агрегата (например, поле структуры)? При этом объект-агрегат должен жить пока жив либо указатель на часть, либо указатель на целое.
Объектно-ориентированное программирование
Понятие класса
Что такое класс
Объявление класса в C++
Проблемы прямого доступа к данным класса. Инкапсуляция.
Методы класса
Указатель this
Константные методы.
Статические данные и методы класса.
mutable-данные класса.
Свойства
Размещение кода класса в .h И .cpp файлах
Чем класс отличается от структуры? Когда использовать структуры, а когда классы?
Модификаторы уровня доступа к содержимому классов
Жизненный цикл объекта
Конструктор
Конструктор по умолчанию
Конвертирующий конструктор
explicit конструктор
Инициализация полей класса в конструкторе. Списки инициализации
Деинициализация класса. Деструктор.
Копирующий конструктор
Копирующий оператор присваивания
Запрет копирования и присваивания
Делегирующий конструктор
Семантика перемещения
Перемещающий конструктор
В чём отличие перемещения от копирования?
Какие преимущества даёт перемещение по сравнению с копированием?
Какие стандартные классы поддерживают семантику перемещения?
В каком состоянии должен остаться объект после перемещения?
Перемещающий оператор присваивания
Когда нужно создавать пользовательские конструктор/деструктор/операции присваивания?
Запрещение присваивания и перемещения объектов
Что делает std::move?
"Правило пяти"
Отношения между классами
Отношение композиции. Обозначение композиции на диаграмме классов.
Как композиция реализуется в C++?
Отношение агрегации. Обозначение агрегации на диаграмме классов.
Как агрегация реализуется в C++?
Чем композиция отличается от агрегации?
Зависимость. Обозначение зависимости на диаграмме классов.
Транзитивность зависимостей.
Чем зависимость отличается от агрегации и композиции?
Когда применять зависимость, когда агрегацию, а когда композицию?
Наследование
Смысл отношения наследования.
Что такое базовый, родительский и производный классы?
Обозначение наследования на диаграммах классов.
Вызов конструкторов и деструкторов при наследовании.
Каковы особенности публичного, приватного и защищённого наследования? Когда их следует применять?
К каким полям и методам класса может иметь доступ класс-наследник?
В каком случае возможно приведение типа вверх по иерархии классов. Как влияет тип наследования на приведение типа по иерархии наследования?
Что произойдёт, если в классе-наследнике будет объявлен метод с тем же именем, что в одном из его родителей?
Как класс-наследник может вызвать одноименный метод своего родителя?
Чем отличается class X final { /*...*/ }; от class X { /*...*/ };. Когда следует объявлять класс или структуру финальной?
Как в функцию void F(Base&) передать ссылку на объект класса class Derived : private Base {...};?
Полиморфизм
Что такое виртуальные методы и для чего они нужны? Чем отличаются виртуальные методы от невиртуальных?
Как переопределить виртуальную функцию в производном классе?
Для чего в C++ деструктор объявляется виртуальным? В каких случаях деструктор не нужно объявлять виртуальным?
Особенности вызова виртуальных функций в конструкторе и деструкторе класса.
Как и для чего применяется спецификатор override у методов?
Как и для чего применяется спецификатор final у методов?
Может ли конструктор быть виртуальным?
Что такое полиморфизм?
Что такое абстрактный класс? Для чего он нужен?
Что такое интерфейс? Как объявить интерфейс в C++?
Чем отличается абстрактный класс от интерфейса?
Как наследование позволяет реализовывать полиморфизм времени выполнения?
Как в большинстве компиляторов реализованы виртуальные функции?
Приведение типа вниз по иерархии классов. Оператор dynamic_cast.
Множественное наследование
Для чего применяется множественное наследование?
В каком порядке вызываются конструкторы и деструкторы при множественном наследовании?
Какие проблемы создаёт наследование от двух и более классов, которые имеют общего предка?
Для чего используется виртуальное наследование в C++? Как его применяют?
Как в C++ реализовать несколько интерфейсов?
Пусть класс Derived унаследован от несвязанных друг с другом классов Base1 и Base2, в каждом из которых есть метод виртуальный метод Foo(). Как в Derived переопределить метод Foo класса Base1?
В чём заключается различие в структуре объекта при виртуальном и невиртуальном наследовании?
Перегрузка арифметических операций и операций сравнения
Перегрузка присваивающих выражений: +=, -=, *=, /=.
Перегрузка бинарных арифметических операций: +, -, *, /.
Особенности перегрузки бинарных операций с разным типом аргументов.
Перегрузка унарного + и -.
Перегрузка операций сравнения: <, >, <=, >=, ==, !=
Операция <=>. Типы ordering-а. default-реализация операции <=>.
Перегрузка прочих операций
Перегрузка операций << и >> для вывода в поток.
Перегрузка операции разыменования * и обращения к полю класса ->. Для чего применяется?
Перегрузка операции индексации []. Как перегрузить операцию [] для чтения и для записи.
Перегрузка операций ++ и --.
Перегрузка операций приведения типа.
Перегрузка операции вызова функции (). Для чего применяются?
Обработка исключений
Выбрасывание исключения.
Перехват исключений заданного типа.
Перехват всех исключений.
Перевыброс пойманного исключения.
Особенности выбрасывания исключений в конструкторе и деструкторе класса
Как указать, что функция или метод не выбрасывают исключений?
Почему рекомендуется перемещающий конструктор и оператор присваивания делать не выбрасывающими исключений?
Что такое срезка? Как избежать срезки при обработке исключений?
Стандартные классы исключений.
Иерархия классов исключений.
Какие преимущества даёт возможность использовать классы в качестве объектов исключений?
Какие средства стандартной библиотеки позволяют узнать, что у класса или структуры конструктор копирования/перемещения не выбрасывает исключений.
Для чего служит класс std::nested_exception? Приведите пример использования.
Как перехватить все исключения стандартной библиотеки?
Разработка кода, устойчивого к возникновению исключений
Какие существуют гарантии безопасности исключений? В чем они заключаются?
Принципы написания кода, устойчивого у возникновению исключений.
Идиома RAII (Resource acquisition is initialization)
Как обеспечить строгую гарантию безопасности исключений при реализации методов?
Как определить, какой уровень безопасности исключений предоставляет функция или метод?
Привести пример кода, небезопасного к возникновению исключений. Продемонстрировать, как обеспечить для этого кода базовую или строгую гарантию безопасности исключений.
Шаблоны функций
Как объявить шаблон функции?
Может ли шаблонная функция не иметь аргументов?
Что может использоваться в качестве параметров шаблона? Приведите пример.
Для чего используется специализация шаблонов функций? Приведите пример специализации шаблонной функции.
Как объявить специализацию шаблонной функции?
Может ли специализация шаблонной функции сама быть шаблоном? Если да, приведите пример.
Как объявляются шаблонные операторы? Приведите пример.
Шаблоны классов
Как объявить шаблон класса?
Как объявляется метод шаблонного класса вне класса?
Как объявляется шаблонный метод класса вне класса?
Как объявляется шаблонный метод шаблонного класса вне класса?
Чем отличается частичная и полная специализация шаблона класса.
Как объявить частичную и полную специализацию шаблона класса?
Может ли виртуальный метод класса быть шаблонным?
Применение шаблонов при построении иерархий классов.
Шаблоны с переменным числом аргументов
Как объявить функцию-шаблон с переменным количеством аргументов?
Как объявить класс-шаблон с переменным количеством аргументов?
Напишите шаблонную функцию Second, принимающую произвольное количество аргументов любого типа и возвращающую второй аргумент.
Как из шаблонной функции, принимающей произвольное число аргументов вызвать другую функцию с произвольным количеством аргументов и передать туда все аргументы?
Свёрточные выражения. Напишите шаблонную функцию ApplyToMany, которая принимает функциональный объект f и произвольное количество аргументов, а потом последовательно вызывает f с каждым из переданных аргументов.
Напишите шаблонную функцию EqualsToOneOf, принимающую один или более аргументов. Функция должна вернуть true, если ёё первый аргумент равен одному из остальных аргументов и false в противном случае.
Напишите шаблонную функцию Last, принимающую произвольное количество аргументов любого типа и возвращающую свой последний аргумент.